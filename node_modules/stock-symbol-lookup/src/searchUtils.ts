
import {utilities} from './utilities';

var searchUtils = {
    data: null,

    search: function (input: string, maxEntries: number, unique: boolean) {
        return Promise.all([
            this.searchBySymbol(input, maxEntries),
            this.searchBySecurity(input, unique ? maxEntries * 2 : maxEntries)
        ])
        .then((results) => {
            var symbols: Array<any> = results[0],
                symbolNames: Array<string> = symbols.map((item: any) => {return item.symbol}),
                securities: Array<any> = [];

            results[1].every((item: any) => {
                if (symbolNames.indexOf(item.symbol) !== -1) {
                    return false;
                }

                securities.push(item);
                return maxEntries ? securities.length < maxEntries : true;
            });

            return [symbols, securities];
        })
    },

    searchAll: function (input: string, maxEntries: number) {
        return new Promise((resolve, reject) => {
            var results: Array<any> = [];

            // if the input value is an empty string don't filter the items
            if (input && input.trim() !== '') {
                let val: string = input.toLowerCase();

                if (!(this.data && this.data.securities && this.data.securities.length)) {
                    resolve(results);
                }

                this.data.securities.every((item: any) => {
                    if (
                        item &&
                        typeof item.securityName === 'string' &&
                        typeof item.symbol === 'string' &&
                        (
                            item.securityName.toLowerCase().indexOf(val) > -1 ||
                            item.symbol.toLowerCase().indexOf(val) > -1
                        )
                    ) {
                        results.push(item);
                    }

                    return maxEntries ? results.length < maxEntries : true;
                });
            }

            resolve(results);
        });
    },

    searchBySymbol: function (input: string, maxEntries: number) {
        return new Promise((resolve, reject) => {
            var results: Array<any> = [];

            if (!(this.data && this.data.symbols && this.data.symbols.length)) {
                resolve(results);
            }

            // if the input value is an empty string don't filter the items
            if (input && input.trim() !== '') {
                let val: string = input.toLowerCase();
                let letterArray: Array<any> = this.data.symbols[utilities.alphabet.indexOf(val.charAt(0))];

                if (!letterArray) {
                    resolve(results);
                }

                letterArray.every((item: any) => {
                    if (
                        item &&
                        typeof item.symbol === 'string' &&
                        item.symbol.toLowerCase().indexOf(val) > -1
                    ) {
                        results.push(item);
                    }

                    return maxEntries ? results.length < maxEntries : true;
                });
            }

            resolve(results);
        });
    },

    searchBySecurity: function (input: string, maxEntries: number) {
        return new Promise((resolve, reject) => {
            var results: Array<any> = [];

            // if the input value is an empty string don't filter the items
            if (input && input.trim() !== '') {
                let val: string = input.toLowerCase();

                if (!(this.data && this.data.securities && this.data.securities.length)) {
                    resolve(results);
                }

                this.data.securities.every((item: any) => {
                    if (
                        item &&
                        typeof item.securityName === 'string' &&
                        item.securityName.toLowerCase().indexOf(val) > -1
                    ) {
                        results.push(item);
                    }

                    return maxEntries ? results.length < maxEntries : true;
                });
            }

            resolve(results);
        });
    }
};

export {searchUtils};

