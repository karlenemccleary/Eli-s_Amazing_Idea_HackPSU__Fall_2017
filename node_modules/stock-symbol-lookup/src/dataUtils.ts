
import * as camelCase from 'camelcase';
import {ftpUtils} from './ftpUtils';
import {utilities} from './utilities';

const files: Array<string> = ['nasdaqlisted.txt', 'otherlisted.txt'];

var dataUtils:any = {
    getData: function () {
        return this.downloadFiles()
        .then(this.parseFiles)
        .then(utilities.mergeArrays)
        .then(this.sortData);
    },

    downloadFiles: function (): Promise<any> {
        var fileDataArray: Array<any> = [];

        return new Promise ((resolve, reject) => {
            files.forEach((file) => {
                ftpUtils.fetchFile(file)
                .then((data) => {
                    if (!data) {
                        reject(new Error('No data received from ' + file));
                    }

                    fileDataArray.push(data);

                    if (fileDataArray.length >= files.length) {
                        resolve(fileDataArray);
                    }
                })
            });
        });
    },

    parseFiles: function (fileDataArray: Array<any>): Promise<any> {
        var parsedDataArray: Array<any> = [];

        return new Promise ((resolve, reject) => {
            fileDataArray.forEach((data) => {
                if (!data) {
                    return;
                }

                var parsedData: Array<any> = [],
                    rows: Array<string> = data.split('\r\n'),
                    headerRow: string = rows.shift(),
                    keys: Array<string> = headerRow.split('|');

                rows.forEach((row) => {
                    let companyMeta: any = {};

                    keys.forEach((key) => {
                        let keyName: string = camelCase(key);

                        if (key === 'NASDAQ Symbol') {
                            keyName = 'symbol';
                        }

                        companyMeta[keyName] = row.split('|')[keys.indexOf(key)];
                    });

                    parsedData.push(companyMeta);
                });

                parsedDataArray.push(parsedData);

                if (parsedDataArray.length >= fileDataArray.length) {
                    resolve(parsedDataArray);
                }
            });
        });
    },

    sortData: function (data: any): Promise<any> {
        return new Promise((resolve, reject) => {
            var indexedData: Array<any> = [];

            utilities.alphabet.forEach((letter, index) => {
                indexedData[index] = [];
            });

            data.forEach((item: any, index: number) => {

                if (!item.symbol) {
                    return;
                }

                var letterIndex: number = utilities.alphabet.indexOf(item.symbol.charAt(0).toLowerCase());

                if (!indexedData[letterIndex]) {
                    return;
                }

                indexedData[letterIndex].push(item);
            });

            utilities.alphabet.forEach((letter, index) => {
                indexedData[index].sort((a, b) => {
                    if (a.symbol < b.symbol) {
                        return -1;
                    }
                    if (a.symbol > b.symbol) {
                        return 1;
                    }
                    return 0;
                });
            });

            resolve({
                symbols: indexedData,
                securities: data
            });
        });
    }
};

export {dataUtils};
